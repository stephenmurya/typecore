import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import { activateFont, deactivateFont } from './main/os-bridge';
import { FontDatabase, FontRecord } from './main/database/FontDatabase';
import { FontScanner } from './main/services/scanner';
import { GoogleFontsService } from './main/services/google-fonts';
import { FontDownloader } from './main/services/downloader';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

console.log('ðŸš€ TypeCore Main Process Started');

// Initialize database and scanner
let fontDb: FontDatabase;
let fontScanner: FontScanner;
let googleFonts: GoogleFontsService;
let downloader: FontDownloader;

app.on('ready', () => {
  console.log('ðŸ“¦ Initializing database and scanner...');
  fontDb = new FontDatabase();
  fontScanner = new FontScanner(fontDb);
  googleFonts = new GoogleFontsService(fontDb);
  downloader = new FontDownloader();
  console.log('âœ… Database and scanner initialized');

  createWindow();
});

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// IPC Handlers

// Font activation with Google Fonts support
ipcMain.handle('font:activate', async (_event, font: FontRecord) => {
  console.log('ðŸ“¥ IPC: font:activate called with:', font.path);
  try {
    let fontPath = font.path;

    // If Google font, download first
    if (font.source === 'google' && font.remoteUrl) {
      console.log('ðŸŒ Google font detected, downloading...');
      fontPath = await downloader.ensureFontCached(font.remoteUrl, font.family);
    }

    const success = activateFont(fontPath);

    if (success) {
      fontDb.setActivation(font.path, true);
    }

    return {
      success,
      message: success ? 'Font activated successfully' : 'Failed to activate font'
    };
  } catch (error) {
    console.error('âŒ Error in font:activate handler:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
});

// Font deactivation
ipcMain.handle('font:deactivate', async (_event, font: FontRecord) => {
  console.log('ðŸ“¥ IPC: font:deactivate called with:', font.path);
  try {
    let fontPath = font.path;

    // If Google font, use cached path
    if (font.source === 'google' && font.remoteUrl) {
      try {
        fontPath = await downloader.ensureFontCached(font.remoteUrl, font.family);
      } catch (e) {
        console.warn('Font not in cache, cannot deactivate');
      }
    }

    const success = deactivateFont(fontPath);

    if (success) {
      fontDb.setActivation(font.path, false);
    }

    return {
      success,
      message: success ? 'Font deactivated successfully' : 'Failed to deactivate font'
    };
  } catch (error) {
    console.error('âŒ Error in font:deactivate handler:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
});

// Directory selection and scanning
ipcMain.handle('font:selectAndScan', async () => {
  console.log('ðŸ“¥ IPC: font:selectAndScan called');
  try {
    const result = await dialog.showOpenDialog({
      properties: ['openDirectory'],
      title: 'Select Font Directory'
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { success: false, count: 0, message: 'Cancelled' };
    }

    const dirPath = result.filePaths[0];
    console.log('ðŸ“‚ Selected directory:', dirPath);

    const count = await fontScanner.scanDirectory(dirPath);

    return {
      success: true,
      count,
      message: `Scanned ${count} fonts`
    };
  } catch (error) {
    console.error('âŒ Error in font:selectAndScan handler:', error);
    return {
      success: false,
      count: 0,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
});

// Get all fonts
ipcMain.handle('font:getAll', async () => {
  console.log('ðŸ“¥ IPC: font:getAll called');
  try {
    const fonts = fontDb.getFonts();
    console.log(`ðŸ“š Returning ${fonts.length} fonts`);
    return fonts;
  } catch (error) {
    console.error('âŒ Error in font:getAll handler:', error);
    return [];
  }
});

// Google Fonts sync
ipcMain.handle('google:sync', async (_event, apiKey: string, limit: number = 100) => {
  console.log('ðŸ“¥ IPC: google:sync called');
  try {
    const count = await googleFonts.syncGoogleFonts(apiKey, limit);
    return {
      success: true,
      count,
      message: `Synced ${count} Google Fonts`
    };
  } catch (error) {
    console.error('âŒ Error in google:sync handler:', error);
    return {
      success: false,
      count: 0,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (fontDb) {
    fontDb.close();
  }

  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
